package limax.xmlgen.cpp;

import java.io.File;
import java.io.PrintStream;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import limax.provider.ViewLifecycle;
import limax.util.StringUtils;
import limax.xmlgen.CachedFileOutputStream;
import limax.xmlgen.FileOperation;
import limax.xmlgen.Main;
import limax.xmlgen.Manager;
import limax.xmlgen.NameStringToIndex;
import limax.xmlgen.Namespace;
import limax.xmlgen.Protocol;
import limax.xmlgen.Service;
import limax.xmlgen.State;
import limax.xmlgen.View;

public class Xmlgen {

	static final String path_xmlgen_inc = "xmlgeninc";
	static final String path_xmlgen_src = "xmlgensrc";
	static final String beans_path_name = "beans";
	static final String protocols_path_name = "protocols";
	static final String views_path_name = "views";

	static final String path_beans = path_xmlgen_inc + File.separator + beans_path_name;
	static final String path_protocols = path_xmlgen_inc + File.separator + protocols_path_name;
	static final String path_views = path_xmlgen_inc + File.separator + views_path_name;

	private final Service service;

	public Xmlgen(Service service) {
		this.service = service;
	}

	public void make() {
		makeXmlgenHpp();
		makeXmlgenCpp();

		CachedFileOutputStream.removeOtherFiles(new File(Main.outputPath, path_xmlgen_inc));
	}

	private void makeXmlgenHpp() {
		try (final PrintStream ps = FileOperation.fopen(Xmlgen.path_xmlgen_inc + File.separator + "xmlgen.h")) {

			ps.println("#pragma once");
			ps.println();
			ps.println("// GENERATE BY XMLGEN. DO NOT EDIT THIS FILE.");
			ps.println();

			for (final String beaninc : allbeanhpps)
				ps.println("#include \"" + Xmlgen.beans_path_name + "/" + beaninc + "\"");
			ps.println();

			for (final Protocol p : service.getProtocols())
				ps.println("#include \"" + Xmlgen.protocols_path_name + "/" + p.getFullName() + ".h\"");

			ps.println();

			for (final Namespace ns : service.getNamespaces()) {
				for (final View v : ns.getViews()) {
					if (v.getLifecycle() == ViewLifecycle.temporary)
						ps.println("#include \"../" + Xmlgen.path_xmlgen_src + "/" + v.getFullName() + ".h\"");
					else
						ps.println("#include \"" + Xmlgen.views_path_name + "/" + v.getFullName() + ".h\"");
				}
			}
			ps.println();

			Xmlgen.begin(service.getParent().getName(), ps);
			ps.println();

			for (Manager mng : service.getManagers()) {
				for (State state : mng.getStates()) {
					ps.println("	std::shared_ptr<limax::State> get" + StringUtils.upper1(mng.getName()) + "State"
							+ StringUtils.upper1(state.getName()) + "(int pvid);");
					ps.println();
				}
			}
			for (final Namespace ns : service.getNamespaces()) {
				if (ns.getViews().isEmpty())
					continue;
				ps.println("	std::shared_ptr<limax::View::ViewCreatorManager> get" + StringUtils.upper1(ns.getName())
						+ "ViewCreatorManager(int pvid);");
				ps.println();
			}
			Xmlgen.end(service.getParent().getName(), ps);
		}
	}

	private void makeXmlgenCpp() {
		try (final PrintStream cpp = FileOperation.fopen(Xmlgen.path_xmlgen_inc + File.separator + "_xmlgen_.hpp")) {
			cpp.println();
			cpp.println("// GENERATE BY XMLGEN. DO NOT EDIT THIS FILE.");
			cpp.println();
			cpp.println("#include <limax.h>");
			cpp.println();
			cpp.println("#include \"xmlgen.h\"");

			cpp.println();

			service.getManagers()
					.forEach(
							manager -> manager.getStates()
									.forEach(
											state -> state.getProtocols()
													.forEach(p -> cpp.println("int "
															+ service.getFullName().replace(".", "::") + "::"
															+ p.getFullName().replace(".", "::") + "::TYPE;"))));

			cpp.println();
			Xmlgen.begin(service.getParent().getName(), cpp);
			cpp.println();
			for (Manager manager : service.getManagers()) {
				for (State state : manager.getStates()) {
					cpp.println("	std::shared_ptr<limax::State> get" + StringUtils.upper1(manager.getName()) + "State"
							+ StringUtils.upper1(state.getName()) + "(int pvid)");
					cpp.println("	{");
					cpp.println("		std::shared_ptr<limax::State> state(new limax::State());");
					state.getProtocols().forEach(p -> {
						final String pclsname = "limax::Protocol::TStub<" + service.getFullName().replace(".", "::")
								+ "::" + p.getFullName().replace(".", "::") + ">";
						cpp.println("		" + service.getFullName().replace(".", "::") + "::"
								+ p.getFullName().replace(".", "::") + "::TYPE=(pvid << 8)|" + p.getType() + ";");
						cpp.println(
								"		state->addStub(std::make_shared< " + pclsname + " >(" + p.getMaxsize() + "));");
					});
					cpp.println("		return state;");
					cpp.println("	}");
					cpp.println();
				}
			}
			for (final Namespace ns : service.getNamespaces()) {
				final List<View> views = ns.getViews();
				if (views.isEmpty())
					continue;
				final NameStringToIndex nameindex = new NameStringToIndex(Short.MAX_VALUE);
				nameindex.addAll(views);
				cpp.println("	std::shared_ptr<limax::View::ViewCreatorManager> get" + StringUtils.upper1(ns.getName())
						+ "ViewCreatorManager(int pvid)");
				cpp.println("	{");
				cpp.println(
						"		std::shared_ptr<limax::View::ViewCreatorManager> vcm(new limax::View::ViewCreatorManager(pvid));");
				views.forEach(view -> {
					final String classname = (service.getFullName() + "." + view.getFullName()).replace(".", "::");
					cpp.println("		vcm->addCreator((int16_t)" + nameindex.getIndex(view)
							+ ", std::make_shared< limax::View::ViewCreatorTemplate<" + classname + "> >());");
				});
				cpp.println("		return vcm;");
				cpp.println("	}");
				cpp.println();
			}

			Xmlgen.end(service.getParent().getName(), cpp);

			cpp.println();
		}

		final String cppfilename = path_xmlgen_src + File.separator + "xmlgen." + (Main.isObjectiveC ? "mm" : "cpp");
		if (new File(cppfilename).isFile())
			return;
		try (final PrintStream cpp = FileOperation.fopen(cppfilename)) {
			cpp.println();
			cpp.println("#include \"../" + path_xmlgen_inc + "/_xmlgen_.hpp\"");
			cpp.println();
		}
	}

	static void begin(String fullName, PrintStream ps) {
		for (String name : fullName.split("\\."))
			ps.println("namespace " + name + " { ");
	}

	static void end(String fullName, PrintStream ps) {
		for (int i = fullName.split("\\.").length; i > 0; i--)
			ps.println("} ");
	}

	static final Set<String> allbeanhpps = new HashSet<>();
}
